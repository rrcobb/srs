// Various Spaced Repetition algorithms
use rand::prelude::*;

// ## Quality
// 
// An integer from 0-5 indicating how easily the information was remembered today. This could correspond to a button such as "Difficult" or "Very Easy."
// 
// The official algorithm description explains the meaning of each number:

#[derive(Copy,Clone,PartialEq,PartialOrd)]
enum Quality {
    Five = 5, // perfect response
    Four = 4, // correct response after a hesitation
    Three = 3, // correct response recalled with serious difficulty
    Two = 2, // incorrect response; where the correct one seemed easy to recall
    One = 1, // incorrect response; the correct one remembered
    Zero = 0, // complete blackout.
}
use Quality::*;

impl Quality {
    fn random() -> Quality {
        let mut rng = thread_rng();
        *[Five, Four, Three, Two, One, Zero].iter().choose(&mut rng).unwrap()
    }
}

// ## Repetitions (integer)
// 
// The number of times the information has been reviewed prior to this review. `repetitions` should equal zero for the first review.
// 
// SM-2 uses this value to define specific intervals for the first and second reviews. SM-2 will also reset this value to zero when `quality` is less than 3.

type Repetitions = u32;
static DEFAULT_REPETITIONS: Repetitions = 0;

// ## Ease factor (float)
// 
// A floating point number (â‰¥ 1.3) generated by the last iteration of the SM-2 algorithm. `previous ease factor` should equal 2.5 for the first review.
// 
// The ease factor is used to determine the number of days to wait before reviewing again. Each call to SM-2 adjusts this number up or down based on `quality`.

type EaseFactor = f32;
static DEFAULT_EASE_FACTOR: EaseFactor = 2.5;

// ## Interval (integer)
// 
// Generated by the last iteration of the SM-2 algorithm. Indicates the number of days to wait between reviews.
// 
// This previous interval is used when calculating the new interval. `previous interval` should equal zero for the first review.

type Interval = u32;
static DEFAULT_INTERVAL: Interval = 0;

fn sm2(quality: Quality, previous_ease_factor: EaseFactor, previous_repetitions: Repetitions, previous_interval: Interval) -> (Interval, Repetitions, EaseFactor) {
    let interval: Interval;
    let mut ease_factor: EaseFactor;
    let repetitions: Repetitions;

    // If `quality` is greater than or equal to 3, indicating a correct response:
    if quality as u32 >= 3 {
        interval = match previous_repetitions {
            // 1. If `repetitions` is 0 (first review), set `interval` to 1 day.
            0 => 1,
            // 2. If `repetitions` is 1 (second review), set `interval` to 6 days.
            1 => 6,
            // 3. If `repetitions` is greater than 1 (subsequent reviews), set `interval` to `previous interval * previous ease factor`. (See note about recursion below.)
        // 4. Round `interval` up to the next whole number.
            _ => (previous_interval as f32 * previous_ease_factor).ceil() as u32
        };
        // 5. Increment `repetitions` by 1.
        repetitions = previous_repetitions + 1;
        // 6. Set `ease factor` to result of ease_factor formula 
        ease_factor = calculate_ease_factor(previous_ease_factor, quality);
    } else {
    // If `quality` is less than 3, indicating an incorrect response:

        // 1. Set `repetitions` to 0.
        repetitions = 0;
        // 2. Set `interval` to 1.
        interval = 1;
        // 3. Set `ease factor` to `previous ease factor` (no change).
        ease_factor = previous_ease_factor
    }

    if ease_factor < 1.3 {
        ease_factor = 1.3;
    }

    (interval, repetitions, ease_factor)
}

fn calculate_ease_factor(previous_ease_factor: EaseFactor, quality: Quality) -> EaseFactor {
    // # Ease factor formula
    // 
    // After the first two reviews, `ease factor` is adjusted using this formula:
    // 
    // The magic numbers come from the official algorithm description.
    // 
    // This increases `ease factor` when `quality` is 5, makes no change when `quality` is 4, and decreases `ease factor` by varying amounts when `quality` is lower than 4. The lower `quality` is, the more `ease factor` is decreased.
    previous_ease_factor + (0.1 - ((5 - quality as u32) as f32) * (0.08 + ((5 - quality as u32) as f32) * 0.02))
}

fn main() {
    let old_ease = 1.8;
    let old_interval = 6;
    let quality = Three;
    let old_repetitions = 3;
    let (new_interval, new_repetitions, new_ease_factor) = sm2(quality, old_ease, old_repetitions, old_interval);
    println!("new interval {}", new_interval);
    println!("new repetitions {}", new_repetitions);
    println!("new ease factor {}", new_ease_factor);
}
